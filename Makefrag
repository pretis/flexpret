
# FLEXPRET_ROOT_DIR, NAME, and APP_SOURCES must be defined in the Makefile that this is included from

ifndef FLEXPRET_ROOT_DIR
$(error FLEXPRET_ROOT_DIR is not set)
endif

ifndef NAME
$(error NAME (name of program) is not set)
endif

ifndef APP_SOURCES
$(error APP_SOURCES is not set)
endif

all: compile

# Include specification for how to build libflexpret
include $(FLEXPRET_ROOT_DIR)/swconfig.mk
include $(FLEXPRET_ROOT_DIR)/programs/lib/Makefrag-lib

ifeq ($(TARGET),emulator)
LINKER_SCRIPT ?= $(FP_LIB_DIR)/linker/flexpret.ld
else
LINKER_SCRIPT ?= $(FP_LIB_DIR)/linker/flexpret_app.ld

LINKER_BOOTLOADER_CONFIG := $(FP_LIB_DIR)/linker/flexpret_bootloader_config.ld
FOUND_BOOTLOADER_CONFIG := $(shell if [ -e $(LINKER_BOOTLOADER_CONFIG) ]; then echo true; else echo false; fi)

ifeq ($(FOUND_BOOTLOADER_CONFIG),false)
$(error Cannot find $(LINKER_BOOTLOADER_CONFIG). Either create one manually (not recommened) or generate one together with a bootloader. The configuration must match the one on the FPGA for the software to work)
endif

endif


RISCV_PREFIX = riscv32-unknown-elf-
CC = $(RISCV_PREFIX)gcc
AR = $(RISCV_PREFIX)ar
OBJDUMP := $(RISCV_PREFIX)objdump
OBJCOPY := $(RISCV_PREFIX)objcopy
EMU ?= $(FLEXPRET_ROOT_DIR)/emulator/fp-emu # Verilator C++ emulator

CFLAGS += -g -static -Os -ffunction-sections -fdata-sections -Wl,--gc-sections -march=rv32i -mabi=ilp32 -nostartfiles --specs=nosys.specs -Werror=stack-usage=$(STACKSIZE) $(APP_DEFS) $(DEFINES)
INCS += $(LIB_INCS) $(APP_INCS)
LFLAGS += -T $(LINKER_SCRIPT) -L $(FP_LIB_DIR)/linker -Xlinker -Map=$(NAME).map 

ALL_SOURCES := $(STARTUP_SOURCES) $(APP_SOURCES) $(LIB_SOURCES)
ALL_OBJECTS := $(patsubst %.c,%.o,$(ALL_SOURCES))

ifeq ($(WANT_DEBUG),true)
CFLAGS += -fstack-protector-all
else
CFLAGS += -fstack-protector
endif

.PHONY: compile riscv dump mem run clean recompile

# Default target; generates the riscv, dump, and mem files
# Double colon makes it possible to extend the target
compile:: autogen riscv dump mem

autogen: $(LIB_AUTOGEN)

# Compiles a C program into a riscv ELF file.
riscv: $(NAME).riscv

%.o: %.c
	@$(CC) $(LFLAGS) $(CFLAGS) $(INCS) -c $< -o $@

%.riscv: $(ALL_OBJECTS)
	@$(CC) $(LFLAGS) $(CFLAGS) $(INCS) -o $*.riscv $^

# Generates a dump file for debugging
dump: $(NAME).dump
%.dump: %.riscv
	@$(OBJDUMP) -S -d $^ > $@

# Generates the .mem file, that can be run with fp-emu
mem: $(NAME).mem
%.mem: %.riscv
	@$(OBJCOPY) -O binary $*.riscv $*.binary.txt
	@xxd -c 4 -e $*.binary.txt | cut -c11-18 > $*.mem
	@xxd -c 4 -e $*.binary.txt > $*.mem.orig
	@rm $*.binary.txt # Delete the temporary binary file

# runs the program (generated .mem file) using fp-emu 
run: $(NAME).mem $(CLIENT)
ifeq ($(CLIENT_CMD),)
	@$(EMU) +ispm=$^
else
	@$(CLIENT_CMD) &
	@$(EMU) +ispm=$^ --client
	@wait
	@killall $(CLIENT)
endif

WARNING := \033[0;33mEnsure $(NAME).mem was compiled with TARGET=fpga, otherwise it will immediately crash\e[0m
USB_PATH ?= /dev/ttyUSB0
FPGA_FLASH_BAUDRATE ?= 115200

flash: $(NAME).mem
	@echo -e "$(WARNING)"
	@python3 $(FLEXPRET_ROOT_DIR)/scripts/serialize_app.py $< $<.serialized
	@python3 $(FLEXPRET_ROOT_DIR)/scripts/send_uart.py $(USB_PATH) $(FPGA_FLASH_BAUDRATE) $<.serialized

pico:
	picocom -b $(FPGA_FLASH_BAUDRATE) $(USB_PATH) --imap lfcrlf

CALLGRAPH_TOP_FUNCTION ?= main

callgraph: autogen callgraph.svg
callgraph.svg: $(STARTUP_SOURCES) $(APP_SOURCES) $(LIB_SOURCES)
	@$(CC) -fdump-rtl-expand $(LFLAGS) $(CFLAGS) $(INCS) -o $(NAME).riscv $^
	@mkdir -p callgraph && mv *.expand callgraph
	@egypt callgraph/*.expand > callgraph/expands.txt 
	@python3 $(FLEXPRET_ROOT_DIR)/scripts/callgraph.py $(CALLGRAPH_TOP_FUNCTION)
	@cat callgraph/expands.txt.modified | dot -Tsvg -o callgraph/callgraph.svg

# Clean and recompile
recompile: clean compile

# Deletes all generated artifacts
# Double colon makes it possible to extend the target
clean::
	rm -f *.vcd *.mem *.riscv *.map *.out *.dump *.orig *.a *.app
	rm -rf callgraph
	rm -f $(LIB_AUTOGEN)
